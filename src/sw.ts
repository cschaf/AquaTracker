/**
 * @file Service Worker for AquaTracker PWA.
 *
 * This service worker is responsible for:
 * 1. Precaching application assets for offline use via Workbox.
 * 2. Handling background reminder notifications.
 * 3. Managing the service worker lifecycle.
 */

/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { IdbReminderRepository } from './infrastructure/data/idb-reminder.repository';

declare const self: ServiceWorkerGlobalScope;

// --- Lifecycle Management & Precaching ---

// Allow this service worker to take control of the page as soon as it's activated.
clientsClaim();
self.skipWaiting();

// Precache all of the assets generated by the build process.
// Their URLs are injected into the manifest variable below.
precacheAndRoute(self.__WB_MANIFEST);

// --- Notification Logic ---

// Instantiate the repository to access reminder data from IndexedDB.
// This uses the exact same repository class as the main application.
const reminderRepository = new IdbReminderRepository();

// Keep track of active notification timers.
let activeTimers: number[] = [];

/**
 * Schedules notifications for all active reminders.
 * This function clears any existing timers and creates new ones based on the
 * current reminder data in IndexedDB.
 */
const scheduleNotifications = async () => {
  // Clear any previously scheduled timers to avoid duplicates.
  activeTimers.forEach(clearTimeout);
  activeTimers = [];

  try {
    const reminders = await reminderRepository.findAll();
    const activeReminders = reminders.filter((r) => r.isActive);

    activeReminders.forEach((reminder) => {
      const now = new Date();
      const [hours, minutes] = reminder.time.split(':').map(Number);

      // Calculate the next occurrence of the reminder time.
      let nextNotificationTime = new Date();
      nextNotificationTime.setHours(hours, minutes, 0, 0);

      // If the time has already passed for today, schedule it for tomorrow.
      if (nextNotificationTime.getTime() < now.getTime()) {
        nextNotificationTime.setDate(nextNotificationTime.getDate() + 1);
      }

      const timeDifference = nextNotificationTime.getTime() - now.getTime();

      // Schedule the notification.
      const timerId = self.setTimeout(() => {
        self.registration.showNotification('AquaTracker Reminder', {
          body: reminder.title,
          icon: '/icons/icon-192-192.png',
          tag: reminder.id, // Use reminder ID as tag to prevent duplicate notifications.
          data: {
            url: `/reminders?id=${reminder.id}`, // Pass URL to open on click.
          },
        });
      }, timeDifference);

      activeTimers.push(timerId);
    });
  } catch (error) {
    console.error('Error scheduling notifications:', error);
  }
};

// --- Event Listeners ---

/**
 * The 'activate' event is fired when the service worker is activated.
 * We schedule notifications here to ensure they are set up when the SW starts.
 */
self.addEventListener('activate', (event) => {
  event.waitUntil(scheduleNotifications());
});

/**
 * The 'message' event listens for messages from the main application.
 * This is used to trigger a re-scheduling of notifications when reminders are
 * created, updated, or deleted in the app.
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'UPDATE_REMINDERS') {
    scheduleNotifications();
  }
});

/**
 * The 'notificationclick' event is fired when a user clicks on a notification.
 * It opens the application and navigates to the relevant reminder page.
 */
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const urlToOpen = event.notification.data.url || '/';

  // Focus the existing client window or open a new one.
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      if (clientList.length > 0) {
        let client = clientList[0];
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            client = clientList[i];
          }
        }
        return client.focus().then(c => c.navigate(urlToOpen));
      }
      return self.clients.openWindow(urlToOpen);
    })
  );
});
