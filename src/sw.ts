/**
 * @file Service Worker for AquaTracker PWA.
 *
 * This service worker is responsible for:
 * 1. Precaching application assets for offline use via Workbox.
 * 2. Handling background reminder notifications.
 * 3. Managing the service worker lifecycle.
 */

/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { IdbReminderRepository } from './infrastructure/data/idb-reminder.repository';

declare const self: ServiceWorkerGlobalScope;

// --- Lifecycle Management & Precaching ---

// Allow this service worker to take control of the page as soon as it's activated.
clientsClaim();
self.skipWaiting();

// Precache all of the assets generated by the build process.
// Their URLs are injected into the manifest variable below.
precacheAndRoute(self.__WB_MANIFEST);

declare const __APP_URL__: string;

// --- Notification Logic ---

// Instantiate the repository to access reminder data from IndexedDB.
// This uses the exact same repository class as the main application.
const reminderRepository = new IdbReminderRepository();

/**
 * Shows a notification if it hasn't been shown recently and updates the
 * reminder's lastNotified timestamp.
 * @param reminder - The reminder to notify for.
 */
const showNotification = async (reminder: import('./domain/entities/reminder.entity').Reminder) => {
  const now = new Date();
  // To avoid spamming the user, check if a notification has been shown in the
  // last 23 hours. This prevents re-showing a notification if the periodic
  // sync fires multiple times in a short period.
  if (reminder.lastNotified) {
    const lastNotified = new Date(reminder.lastNotified);
    const twentyThreeHours = 23 * 60 * 60 * 1000;
    if (now.getTime() - lastNotified.getTime() < twentyThreeHours) {
      console.log(`Service Worker: Notification for "${reminder.title}" was already shown recently.`);
      return;
    }
  }

  await self.registration.showNotification('AquaTracker Reminder', {
    body: reminder.title,
    icon: '/icons/icon-192-192.png',
    tag: reminder.id,
    data: {
      url: __APP_URL__,
    },
  });
  reminder.setLastNotified(now);
  await reminderRepository.save(reminder);
  console.log(`Service Worker: Notification shown for "${reminder.title}".`);
};

/**
 * Checks all active reminders from IndexedDB to see if a notification is due.
 * This function is the core of the new notification logic, designed to be
 * called by service worker events like 'periodicsync' or 'activate'.
 */
const checkReminders = async () => {
  console.log('Service Worker: Checking for due reminders...');

  try {
    const reminders = await reminderRepository.findAll();
    const activeReminders = reminders.filter((r) => r.isActive);

    if (activeReminders.length === 0) {
      console.log('Service Worker: No active reminders.');
      return;
    }

    for (const reminder of activeReminders) {
      const now = new Date();
      const [hours, minutes] = reminder.time.split(':').map(Number);

      const reminderTimeToday = new Date();
      reminderTimeToday.setHours(hours, minutes, 0, 0);

      // If the reminder time for today has passed, we should check if a notification is due.
      if (reminderTimeToday.getTime() < now.getTime()) {
        await showNotification(reminder);
      }
    }
  } catch (error) {
    console.error('Service Worker: Error checking reminders:', error);
  }
};

// --- Event Listeners ---

/**
 * The 'activate' event is fired when the service worker is activated.
 * We check reminders here to handle any missed notifications when the SW starts.
 */
self.addEventListener('activate', (event) => {
  event.waitUntil(checkReminders());
});

/**
 * The 'message' event listens for messages from the main application.
 * This is used to trigger a check of reminders when they are updated in the app.
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'UPDATE_REMINDERS') {
    checkReminders();
  }
});

interface PeriodicSyncEvent extends ExtendableEvent {
  tag: string;
}

/**
 * The 'periodicsync' event is the primary mechanism for triggering background
 * notifications. It runs periodically as determined by the browser.
 */
self.addEventListener('periodicsync', (event) => {
  const periodicSyncEvent = event as PeriodicSyncEvent;
  if (periodicSyncEvent.tag === 'UPDATE_REMINDERS') {
    periodicSyncEvent.waitUntil(checkReminders());
  }
});

/**
 * The 'notificationclick' event is fired when a user clicks on a notification.
 * It opens the application and navigates to the relevant reminder page.
 */
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const urlToOpen = event.notification.data.url || '/';

  // Focus the existing client window or open a new one.
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      if (clientList.length > 0) {
        let client = clientList[0];
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            client = clientList[i];
          }
        }
        return client.focus().then(c => c.navigate(urlToOpen));
      }
      return self.clients.openWindow(urlToOpen);
    })
  );
});
