/**
 * @file Service Worker for AquaTracker PWA.
 *
 * This service worker is responsible for:
 * 1. Precaching application assets for offline use via Workbox.
 * 2. Handling background reminder notifications.
 * 3. Managing the service worker lifecycle.
 */

/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { IdbReminderRepository } from './infrastructure/data/idb-reminder.repository';

declare const self: ServiceWorkerGlobalScope;

// --- Lifecycle Management & Precaching ---

// Allow this service worker to take control of the page as soon as it's activated.
clientsClaim();
self.skipWaiting();

// Precache all of the assets generated by the build process.
// Their URLs are injected into the manifest variable below.
precacheAndRoute(self.__WB_MANIFEST);

declare const __APP_URL__: string;

// --- Notification Logic ---

// Instantiate the repository to access reminder data from IndexedDB.
// This uses the exact same repository class as the main application.
const reminderRepository = new IdbReminderRepository();

// Keep track of active notification timers.
let activeTimers: number[] = [];

/**
 * Shows a notification and updates the reminder's lastNotified timestamp.
 * @param reminder - The reminder to notify for.
 */
const showNotification = async (reminder: import('./domain/entities/reminder.entity').Reminder) => {
  await self.registration.showNotification('AquaTracker Reminder', {
    body: reminder.title,
    icon: '/icons/icon-192-192.png',
    tag: reminder.id,
    data: {
      url: __APP_URL__,
    },
  });
  reminder.setLastNotified(new Date());
  await reminderRepository.save(reminder);
};

/**
 * Schedules notifications for all active reminders.
 * This function clears any existing timers and creates new ones based on the
 * current reminder data in IndexedDB. It also handles missed notifications
 * that should have been shown while the service worker was inactive.
 */
const scheduleNotifications = async () => {
  console.log('Service Worker: Scheduling notifications...');
  activeTimers.forEach(clearTimeout);
  activeTimers = [];

  try {
    const reminders = await reminderRepository.findAll();
    const activeReminders = reminders.filter((r) => r.isActive);

    if (activeReminders.length === 0) {
      console.log('Service Worker: No active reminders to schedule.');
      return;
    }

    for (const reminder of activeReminders) {
      const now = new Date();
      const [hours, minutes] = reminder.time.split(':').map(Number);

      let nextNotificationTime = new Date();
      nextNotificationTime.setHours(hours, minutes, 0, 0);

      // If the notification time for today has already passed, schedule it for tomorrow.
      if (nextNotificationTime.getTime() < now.getTime()) {
        nextNotificationTime.setDate(nextNotificationTime.getDate() + 1);
      }

      // Check if a notification was missed.
      // A notification is considered missed if the last notification was more than 24 hours ago
      // and the scheduled time is in the past.
      if (reminder.lastNotified) {
        const lastNotified = new Date(reminder.lastNotified);
        const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        if (lastNotified < twentyFourHoursAgo && nextNotificationTime < now) {
          console.log(`Service Worker: Missed notification for "${reminder.title}". Showing now.`);
          await showNotification(reminder);
          // Recalculate next notification time for the following day
          nextNotificationTime.setDate(nextNotificationTime.getDate() + 1);
        }
      } else if (nextNotificationTime < now) {
        // If there's no lastNotified date and the time is in the past,
        // it means the user just created a reminder for a time that already passed today.
        // We should notify them for the first time.
        console.log(`Service Worker: First notification for "${reminder.title}" is in the past. Showing now.`);
        await showNotification(reminder);
        nextNotificationTime.setDate(nextNotificationTime.getDate() + 1);
      }


      const timeDifference = nextNotificationTime.getTime() - now.getTime();
      const twentyFourHours = 24 * 60 * 60 * 1000;

      if (timeDifference > 0 && timeDifference < twentyFourHours) {
        console.log(`Service Worker: Scheduling notification for "${reminder.title}" in ${timeDifference / 1000 / 60} minutes.`);
        const timerId = self.setTimeout(() => {
          showNotification(reminder);
        }, timeDifference);
        activeTimers.push(timerId);
      }
    }
  } catch (error) {
    console.error('Service Worker: Error scheduling notifications:', error);
  }
};

// --- Event Listeners ---

/**
 * The 'activate' event is fired when the service worker is activated.
 * We schedule notifications here to ensure they are set up when the SW starts.
 */
self.addEventListener('activate', (event) => {
  event.waitUntil(scheduleNotifications());
});

/**
 * The 'message' event listens for messages from the main application.
 * This is used to trigger a re-scheduling of notifications when reminders are
 * created, updated, or deleted in the app.
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'UPDATE_REMINDERS') {
    scheduleNotifications();
  }
});

interface PeriodicSyncEvent extends ExtendableEvent {
  tag: string;
}

self.addEventListener('periodicsync', (event) => {
  const periodicSyncEvent = event as PeriodicSyncEvent;
  if (periodicSyncEvent.tag === 'UPDATE_REMINDERS') {
    periodicSyncEvent.waitUntil(scheduleNotifications());
  }
});

/**
 * The 'notificationclick' event is fired when a user clicks on a notification.
 * It opens the application and navigates to the relevant reminder page.
 */
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const urlToOpen = event.notification.data.url || '/';

  // Focus the existing client window or open a new one.
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      if (clientList.length > 0) {
        let client = clientList[0];
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            client = clientList[i];
          }
        }
        return client.focus().then(c => c.navigate(urlToOpen));
      }
      return self.clients.openWindow(urlToOpen);
    })
  );
});
