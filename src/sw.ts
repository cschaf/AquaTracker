/**
 * @file Service Worker for AquaTracker PWA.
 *
 * This service worker is responsible for:
 * 1. Precaching application assets for offline use via Workbox.
 * 2. Handling background push notifications from Firebase Cloud Messaging.
 * 3. Managing the service worker lifecycle.
 */

/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { initializeApp } from 'firebase/app';
import { getMessaging, onBackgroundMessage } from 'firebase/messaging/sw';

declare const self: ServiceWorkerGlobalScope;

// --- Lifecycle Management & Precaching ---

// Allow this service worker to take control of the page as soon as it's activated.
clientsClaim();
self.skipWaiting();

// Precache all of the assets generated by the build process.
precacheAndRoute(self.__WB_MANIFEST);

// --- Firebase Push Notification Logic ---

// Initialize the Firebase app with the configuration from environment variables.
// These are injected by Vite during the build process.
const firebaseApp = initializeApp({
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
});

const messaging = getMessaging(firebaseApp);

/**
 * Listen for incoming push messages when the app is in the background.
 * The message payload is determined by our Cloudflare Worker.
 */
onBackgroundMessage(messaging, (payload) => {
  console.log('[sw.ts] Received background message: ', payload);

  const notificationTitle = payload.notification?.title || 'AquaTracker';
  const notificationOptions = {
    body: payload.notification?.body || 'You have a new reminder.',
    icon: payload.notification?.icon || '/icons/icon-192-192.png',
    data: {
      url: payload.data?.url || '/',
    },
  };

  self.registration.showNotification(notificationTitle, notificationOptions);
});


/**
 * The 'notificationclick' event is fired when a user clicks on a notification.
 * It opens the application and navigates to the relevant page.
 */
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const urlToOpen = event.notification.data.url || '/';

  // Focus the existing client window or open a new one.
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      if (clientList.length > 0) {
        let client = clientList[0];
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            client = clientList[i];
          }
        }
        return client.focus().then(c => c.navigate(urlToOpen));
      }
      return self.clients.openWindow(urlToOpen);
    })
  );
});